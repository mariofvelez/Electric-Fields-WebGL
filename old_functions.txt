vec3 computeRing(Ring ring, vec3 pos) // old compute ring shader function
{
    float subdivisions = 100.0;
    vec3 Exyz = vec3(0.0, 0.0, 0.0);
    float dq = ring.q / subdivisions;
    vec3 up = vec3(0.001, 0.32861, -0.2381); // pre-compute a normalized up vector
    up = normalize(up);
    vec3 tz = ring.normal;
    vec3 tx = normalize(cross(tz, up));
    vec3 ty = normalize(cross(tz, tx));
    for(float i = 0.0; i < subdivisions; ++i)
    {
        float angle = (2.0 * pi * i) / subdivisions;
        vec2 uv = vec2(ring.radius * cos(angle), ring.radius * sin(angle));
        vec3 p = uv.x * tx + uv.y * ty + ring.pos;

        vec3 dist_v = pos - p;
        float r2 = dot(dist_v, dist_v);
        float dE = 1.0 / (4.0 * pi * E0) * (dq / r2);
        vec3 dExyz = normalize(dist_v);
        dExyz *= dE;
        Exyz += dExyz;
    }
    return Exyz;
}

vec3 computeDisc(Disc disc, vec3 pos) // old compute disc shader function
{
    float subdivisions_r = 100.0;
    float subdivisions_theta = 100.0;
    float dtheta = 1.0 / subdivisions_theta;
    float dr = 1.0 / subdivisions_r;

    vec3 Exyz = vec3(0.0, 0.0, 0.0);

    vec3 up = vec3(0.001, 0.32861, -0.2381); // pre-compute a normalized up vector
    up = normalize(up);
    vec3 tz = disc.normal;
    vec3 tx = normalize(cross(tz, up));
    vec3 ty = normalize(cross(tz, tx));
    for(float i = 0.0; i < subdivisions_r; ++i) // r
    {
        float r = i / subdivisions_r * disc.radius;
        float ds = r * dtheta;
        for(float j = 0.0; j < subdivisions_theta; ++j) // theta
        {
            float theta = 2.0 * pi * j / subdivisions_theta;
            float dA = dr * ds;
            float dq = disc.sigma * dA;

            vec2 uv = vec2(r * cos(theta), r * sin(theta));
            vec3 p = uv.x * tx + uv.y * ty + disc.pos;

            vec3 dist_v = pos - p;
            float r2 = dot(dist_v, dist_v);
            float dE = 1.0 / (4.0 * pi * E0) * (dq / r2);
            vec3 dExyz = normalize(dist_v);
            dExyz *= dE;
            Exyz += dExyz;
        }
    }
    return Exyz;
}

vec3 computeWasher(Washer washer, vec3 pos) // old compute washer shader function
{
    float subdivisions_r = 50.0;
    float subdivisions_theta = 150.0;
    float dtheta = 1.0 / subdivisions_theta;
    float dr = 1.0 / subdivisions_r;

    vec3 Exyz = vec3(0.0, 0.0, 0.0);

    vec3 up = vec3(0.001, 0.32861, -0.2381); // pre-compute a normalized up vector
    up = normalize(up);
    vec3 tz = washer.normal;
    vec3 tx = normalize(cross(tz, up));
    vec3 ty = normalize(cross(tz, tx));
    for(float i = 0.0; i < subdivisions_r; ++i) // r
    {
        float r = washer.inner + (i / subdivisions_r) * (washer.outer - washer.inner);
        float ds = r * dtheta;
        for(float j = 0.0; j < subdivisions_theta; ++j) // theta
        {
            float theta = 2.0 * pi * j / subdivisions_theta;
            float dA = dr * ds;
            float dq = washer.sigma * dA;

            vec2 uv = vec2(r * cos(theta), r * sin(theta));
            vec3 p = uv.x * tx + uv.y * ty + washer.pos;

            vec3 dist_v = pos - p;
            float r2 = dot(dist_v, dist_v);
            float dE = 1.0 / (4.0 * pi * E0) * (dq / r2);
            vec3 dExyz = normalize(dist_v);
            dExyz *= dE;
            Exyz += dExyz;
        }
    }
    return Exyz;
}