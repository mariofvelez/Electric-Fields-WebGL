<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebGL Test</title>
</head>
<body>
    <script id="Vertex-shader" type="vertex">
        #version 300 es

        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 normal;

        out vec3 vPos;
        out vec3 vNormal;

        uniform mat4 uViewProjection;
        uniform mat4 uModel;

        void main()
        {
            vec4 pos = vec4(position, 1.0);
            vPos = (uModel * pos).xyz;
            vNormal = (uModel * vec4(normal, 0.0)).xyz;
            gl_Position = uViewProjection * uModel * pos;
        }
    </script>
    <script id="Fragment-shader" type="fragment">
        #version 300 es
        precision highp float;

        in vec3 vPos;
        in vec3 vNormal;
        out vec4 fragColor;

        uniform float uCharge;

        void main()
        {
            vec3 light_dir = normalize(vec3(5, 5, 5) - vPos);
            vec3 normal = normalize(vNormal);
            float light = clamp(dot(light_dir, normal), 0.0, 1.0) * 0.5;

            light += 0.5;

            vec3 warm = vec3(1.0, 0.447, 0.23);
            vec3 cool = vec3(0.184, 0.0588, 0.569);

            fragColor = vec4((mix(cool, warm, (uCharge / 20.0) + 0.5) * light), 1.0);
        }
    </script>
    <script id="GridVertex-shader" type="vertex">
        #version 300 es

        layout (location = 0) in vec3 position;

        uniform mat4 uViewProjection;
        uniform mat4 uModel;

        void main()
        {
            vec4 pos = vec4(position, 1.0);
            gl_Position = uViewProjection * uModel * pos;
        }
    </script>
    <script id="GridFragment-shader" type="fragment">
        #version 300 es
        precision highp float;

        out vec4 fragColor;

        void main()
        {
            fragColor = vec4(0.702, 0.98, 0.106, 1.0);
        }
    </script>
    <script id="ArrowVertex-shader" type="vertex">
        #version 300 es

        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 color;
        layout (location = 2) in mat4 model;

        out vec3 Color;

        uniform mat4 uViewProjection;

        void main()
        {
            vec4 pos = vec4(position, 1.0);
            gl_Position = uViewProjection * model * pos;
            Color = color;
        }
    </script>
    <script id="ArrowFragment-shader" type="fragment">
        #version 300 es
        precision highp float;

        in vec3 Color;

        out vec4 fragColor;

        void main()
        {
            fragColor = vec4(Color, 1.0);
        }
    </script>
    <script id="ArrowComputeVertex-shader" type="vertex">
        # version 300 es

        layout (location = 0) in vec3 vpos; // position of the vector

        out vec3 color;     // output color
        out mat4 transform; // output transform

        uniform mat4 grid_matrix;
        float E0 = 1.0;
        float pi = 3.14159265358979;

        float min_color = 0.01;
        float max_color = 1.0;

        // shapes go here
        uniform vec3 pos;
        uniform float charge;

        struct Point {
            vec3 pos;
            float q;
        };
        struct LineSegment {
            vec3 a;
            vec3 b;
            float q;
        };
        struct Plane {
            vec3 normal;
            vec3 pos;
            float sigma;
        };
        struct Ring {
            vec3 normal;
            vec3 pos;
            float radius;
            float lambda;
        };
        struct Disc {
            vec3 normal;
            vec3 pos;
            float radius;
            float sigma;
        };
        struct Washer {
            vec3 normal;
            vec3 pos;
            float inner;
            float outer;
            float sigma;
        };

        float map(float value, float min1, float max1, float min2, float max2) {
            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        }

        vec3 computePoint(Point point, vec3 pos)
        {
            vec3 dist_v = pos - point.pos;
            float r2 = dot(dist_v, dist_v);
            float E = 1.0 / (4.0 * pi * E0) * (point.q / r2);
            vec3 Exyz = normalize(dist_v);

            Exyz *= E;

            return Exyz;
        }

        vec3 computeLineSegment(LineSegment ls, vec3 pos)
        {
            float dq_length = 10.0;
            vec3 Exyz = vec3(0.0, 0.0, 0.0);
            float dq = ls.q / dq_length;
            for(float i = 0.0; i < dq_length; ++i)
            {
                vec3 p = mix(ls.a, ls.b, (i / dq_length) + (1.0 / (dq_length * 2.0))); // middle of dl

                vec3 dist_v = pos - p;
                float r2 = dot(dist_v, dist_v);
                float dE = 1.0 / (4.0 * pi * E0) * (dq / r2);
                vec3 dExyz = normalize(dist_v);
                dExyz *= dE;
                Exyz += dExyz;
            }
            return Exyz;
        }

        /*vec3 computePlane(Plane plane, vec3 pos)
        {
            
        }*/

        void main()
        {
            // calculate electric field vector at vpos
            // this one just calculates the direction away from the field
            Point Q1;
            Q1.pos = pos;
            Q1.q = charge;
            LineSegment Q2;
            Q2.a = pos;
            Q2.b = vec3(0.0, -2.0, 0.0);
            Q2.q = 20.0;
            vec3 z = computePoint(Q1, vpos);//computeLineSegment(Q2, vpos);

            float mag = length(z);

            // generate color
            float col = clamp(mag, min_color, max_color);
            col = map(col, min_color, max_color, 0.0, 1.0);
            color = mix(vec3(0.0, 0.0117, 0.6784), vec3(0.941, 0.2039, 0.1215), col);

            // clamp z between min and max value
            float arrow_size = clamp(mag, 0.05, 1.0);
            z *= (arrow_size / mag);

            // calculate orientation matrix
            vec3 x = normalize(cross(vpos, vec3(0.0003, 1.0, 0.0001))) * arrow_size;
            vec3 y = normalize(cross(z, x)) * arrow_size;

            transform[0] = vec4(x, 0.0);//vec4(x, vpos.x);
            transform[1] = vec4(y, 0.0);//vec4(y, vpos.y);
            transform[2] = vec4(z, 0.0);//vec4(z, vpos.z);
            transform[3] = vec4(vpos, 1.0);
        }
    </script>
    <script id="ArrowComputeFragment-shader" type="fragment">
        #version 300 es
        precision highp float;
        void main() {}
    </script>
    <div>
        <button id="add-charge-button">Add Charge</button>
        <input type="range" min="1" max="100" value="10" id="test-slider">
    </div>
    <div id="controls">

    </div>
    <div class="container">
        <canvas id="c"></canvas>
    </div>
    <script src="gl-matrix.js"></script>
    <script src="application.js"></script>
</body>
</html>